/**
 * TeammateBridge - Core bridge to Claude Code's TeammateTool
 *
 * Provides unified API for multi-agent orchestration using
 * native TeammateTool capabilities (Claude Code >= 2.1.19).
 *
 * Features:
 * - Team management (spawn, discover, join/leave)
 * - Mailbox messaging (write, broadcast)
 * - Plan approval workflow
 * - Delegation system
 * - Remote sync to Claude.ai
 * - Session memory persistence
 * - Teleport/session resume
 *
 * @module @claude-flow/teammate-plugin/bridge
 * @version 1.0.0-alpha.1
 */

import { EventEmitter } from 'events';
import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

import type {
  TeamConfig,
  TeammateSpawnConfig,
  TeamState,
  TeammateInfo,
  MailboxMessage,
  TeamPlan,
  PlanStep,
  TeamContext,
  DelegationRecord,
  RemoteSession,
  SyncResult,
  TeammateMemory,
  TeleportTarget,
  TeleportResult,
  AgentInput,
  ExitPlanModeInput,
  VersionInfo,
  PluginConfig,
  TeammateBridgeEvents,
  JoinRequest,
  MessageType,
  PlanStatus,
  BackendStatus,
  TmuxBackendConfig,
} from './types.js';

import {
  MINIMUM_CLAUDE_CODE_VERSION,
  DEFAULT_PLUGIN_CONFIG,
  TeammateErrorCode,
} from './types.js';

// ============================================================================
// TeammateError Class
// ============================================================================

export class TeammateError extends Error {
  constructor(
    message: string,
    public readonly code: TeammateErrorCode,
    public readonly teamName?: string,
    public readonly teammateId?: string,
    public readonly cause?: Error
  ) {
    super(message);
    this.name = 'TeammateError';
  }
}

// ============================================================================
// Utility Functions
// ============================================================================

function generateId(prefix: string): string {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).slice(2, 10);
  return `${prefix}-${timestamp}-${random}`;
}

function compareVersions(a: string, b: string): number {
  const partsA = a.split('.').map(Number);
  const partsB = b.split('.').map(Number);

  for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {
    const numA = partsA[i] || 0;
    const numB = partsB[i] || 0;
    if (numA > numB) return 1;
    if (numA < numB) return -1;
  }
  return 0;
}

function ensureDirectory(dirPath: string): void {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

// ============================================================================
// TeammateBridge Class
// ============================================================================

export class TeammateBridge extends EventEmitter {
  private claudeCodeVersion: string | null = null;
  private teammateToolAvailable: boolean = false;
  private initialized: boolean = false;

  private activeTeams: Map<string, TeamState> = new Map();
  private mailboxPollers: Map<string, NodeJS.Timeout> = new Map();
  private memoryPersistTimers: Map<string, NodeJS.Timeout> = new Map();
  private teammateMemories: Map<string, TeammateMemory> = new Map();

  private readonly config: PluginConfig;
  private readonly teamsDir: string;

  constructor(config: Partial<PluginConfig> = {}) {
    super();
    this.config = { ...DEFAULT_PLUGIN_CONFIG, ...config };
    this.teamsDir = path.join(os.homedir(), '.claude', 'teams');
  }

  // ==========================================================================
  // Initialization
  // ==========================================================================

  /**
   * Initialize the bridge
   * Detects Claude Code version and TeammateTool availability
   */
  async initialize(): Promise<VersionInfo> {
    if (this.initialized) {
      return this.getVersionInfo();
    }

    // Detect Claude Code version
    try {
      const output = execSync('claude --version 2>/dev/null', {
        encoding: 'utf-8',
        timeout: 5000,
      }).trim();

      const match = output.match(/(\d+\.\d+\.\d+)/);
      this.claudeCodeVersion = match?.[1] ?? null;

      // TeammateTool requires >= 2.1.19
      if (this.claudeCodeVersion) {
        this.teammateToolAvailable =
          compareVersions(this.claudeCodeVersion, MINIMUM_CLAUDE_CODE_VERSION) >= 0;
      }
    } catch {
      this.claudeCodeVersion = null;
      this.teammateToolAvailable = false;
    }

    this.initialized = true;

    const versionInfo = this.getVersionInfo();

    this.emit('initialized', {
      claudeCodeVersion: this.claudeCodeVersion,
      teammateToolAvailable: this.teammateToolAvailable,
    });

    if (!this.teammateToolAvailable) {
      console.warn(
        `[TeammateBridge] TeammateTool not available. ` +
        `Requires Claude Code >= ${MINIMUM_CLAUDE_CODE_VERSION}, ` +
        `found: ${this.claudeCodeVersion ?? 'not installed'}`
      );
    }

    return versionInfo;
  }

  /**
   * Get version information
   */
  getVersionInfo(): VersionInfo {
    const missingFeatures: string[] = [];

    if (!this.teammateToolAvailable) {
      missingFeatures.push('TeammateTool', 'team_name', 'launchSwarm');
    }

    return {
      claudeCode: this.claudeCodeVersion,
      plugin: '1.0.0-alpha.1',
      compatible: this.teammateToolAvailable,
      missingFeatures,
    };
  }

  /**
   * Check if TeammateTool is available
   */
  isAvailable(): boolean {
    return this.teammateToolAvailable;
  }

  /**
   * Get Claude Code version
   */
  getClaudeCodeVersion(): string | null {
    return this.claudeCodeVersion;
  }

  // ==========================================================================
  // Team Management
  // ==========================================================================

  /**
   * Spawn a new team
   */
  async spawnTeam(config: Partial<TeamConfig> & { name: string }): Promise<TeamState> {
    this.ensureAvailable();

    const fullConfig: TeamConfig = {
      topology: 'hierarchical',
      maxTeammates: 8,
      spawnBackend: 'auto',
      planModeRequired: false,
      autoApproveJoin: true,
      messageRetention: 3600000,
      delegationEnabled: true,
      remoteSync: this.config.remoteSync,
      ...config,
    };

    const teamState: TeamState = {
      name: fullConfig.name,
      createdAt: new Date(),
      teammates: [],
      pendingJoinRequests: [],
      activePlans: [],
      messageCount: 0,
      topology: fullConfig.topology,
      context: {
        teamName: fullConfig.name,
        sharedVariables: {},
        inheritedPermissions: [],
        workingDirectory: process.cwd(),
        gitBranch: this.getCurrentGitBranch(),
        gitRepo: this.getCurrentGitRepo(),
        environmentVariables: {},
      },
      delegations: [],
    };

    // Set environment for team context
    process.env.CLAUDE_CODE_TEAM_NAME = fullConfig.name;

    if (fullConfig.planModeRequired) {
      process.env.CLAUDE_CODE_PLAN_MODE_REQUIRED = 'true';
    }

    // Create team directory
    const teamDir = path.join(this.teamsDir, fullConfig.name);
    ensureDirectory(teamDir);
    ensureDirectory(path.join(teamDir, 'mailbox'));
    ensureDirectory(path.join(teamDir, 'memory'));

    // Save team config
    fs.writeFileSync(
      path.join(teamDir, 'config.json'),
      JSON.stringify(fullConfig, null, 2),
      'utf-8'
    );

    this.activeTeams.set(fullConfig.name, teamState);

    // Start mailbox polling
    this.startMailboxPoller(fullConfig.name);

    // Start memory persistence if enabled
    if (this.config.memory.autoPersist) {
      this.startMemoryPersistence(fullConfig.name);
    }

    this.emit('team:spawned', { team: fullConfig.name, config: fullConfig });

    return teamState;
  }

  /**
   * Discover existing teams
   */
  async discoverTeams(): Promise<string[]> {
    this.ensureAvailable();

    try {
      if (!fs.existsSync(this.teamsDir)) {
        return [];
      }

      const entries = fs.readdirSync(this.teamsDir, { withFileTypes: true });
      return entries
        .filter(d => d.isDirectory())
        .filter(d => fs.existsSync(path.join(this.teamsDir, d.name, 'config.json')))
        .map(d => d.name);
    } catch {
      return [];
    }
  }

  /**
   * Load an existing team
   */
  async loadTeam(teamName: string): Promise<TeamState> {
    this.ensureAvailable();

    const teamDir = path.join(this.teamsDir, teamName);
    const configPath = path.join(teamDir, 'config.json');

    if (!fs.existsSync(configPath)) {
      throw new TeammateError(
        `Team not found: ${teamName}`,
        TeammateErrorCode.TEAM_NOT_FOUND,
        teamName
      );
    }

    const config = JSON.parse(fs.readFileSync(configPath, 'utf-8')) as TeamConfig;

    // Load state file if exists
    const statePath = path.join(teamDir, 'state.json');
    let teamState: TeamState;

    if (fs.existsSync(statePath)) {
      const savedState = JSON.parse(fs.readFileSync(statePath, 'utf-8'));
      teamState = {
        ...savedState,
        createdAt: new Date(savedState.createdAt),
        teammates: savedState.teammates.map((t: any) => ({
          ...t,
          spawnedAt: new Date(t.spawnedAt),
          lastHeartbeat: t.lastHeartbeat ? new Date(t.lastHeartbeat) : undefined,
        })),
      };
    } else {
      teamState = {
        name: teamName,
        createdAt: new Date(),
        teammates: [],
        pendingJoinRequests: [],
        activePlans: [],
        messageCount: 0,
        topology: config.topology,
        context: {
          teamName,
          sharedVariables: {},
          inheritedPermissions: [],
          workingDirectory: process.cwd(),
          environmentVariables: {},
        },
        delegations: [],
      };
    }

    this.activeTeams.set(teamName, teamState);

    // Start mailbox polling
    this.startMailboxPoller(teamName);

    return teamState;
  }

  /**
   * Request to join an existing team
   */
  async requestJoin(teamName: string, agentInfo: Partial<TeammateInfo> & { id: string; name: string; role: string }): Promise<void> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);

    const request: JoinRequest = {
      agentId: agentInfo.id,
      agentName: agentInfo.name,
      requestedAt: new Date(),
      role: agentInfo.role,
    };

    team.pendingJoinRequests.push(request);

    this.emit('team:join_requested', {
      team: teamName,
      agent: {
        id: agentInfo.id,
        name: agentInfo.name,
        role: agentInfo.role,
        status: 'idle',
        spawnedAt: new Date(),
        messagesSent: 0,
        messagesReceived: 0,
      } as TeammateInfo,
    });

    // Auto-approve if configured
    const teamDir = path.join(this.teamsDir, teamName);
    const configPath = path.join(teamDir, 'config.json');
    if (fs.existsSync(configPath)) {
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8')) as TeamConfig;
      if (config.autoApproveJoin) {
        await this.approveJoin(teamName, agentInfo.id);
      }
    }
  }

  /**
   * Approve a join request
   */
  async approveJoin(teamName: string, agentId: string): Promise<void> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);

    const requestIndex = team.pendingJoinRequests.findIndex(r => r.agentId === agentId);

    if (requestIndex === -1) {
      throw new TeammateError(
        `No pending join request for agent: ${agentId}`,
        TeammateErrorCode.TEAMMATE_NOT_FOUND,
        teamName,
        agentId
      );
    }

    const request = team.pendingJoinRequests.splice(requestIndex, 1)[0];

    const teammate: TeammateInfo = {
      id: agentId,
      name: request.agentName,
      role: request.role,
      status: 'active',
      spawnedAt: new Date(),
      messagesSent: 0,
      messagesReceived: 0,
    };

    team.teammates.push(teammate);

    this.emit('team:join_approved', { team: teamName, agent: agentId });
  }

  /**
   * Reject a join request
   */
  async rejectJoin(teamName: string, agentId: string, reason?: string): Promise<void> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);

    team.pendingJoinRequests = team.pendingJoinRequests.filter(r => r.agentId !== agentId);

    this.emit('team:join_rejected', { team: teamName, agent: agentId, reason });
  }

  // ==========================================================================
  // Teammate Spawning
  // ==========================================================================

  /**
   * Spawn a teammate using native AgentInput
   */
  async spawnTeammate(config: TeammateSpawnConfig): Promise<TeammateInfo> {
    this.ensureAvailable();

    const teamName = config.teamName ?? process.env.CLAUDE_CODE_TEAM_NAME;

    if (teamName) {
      const team = this.activeTeams.get(teamName);
      if (team) {
        const teamDir = path.join(this.teamsDir, teamName);
        const configPath = path.join(teamDir, 'config.json');
        if (fs.existsSync(configPath)) {
          const teamConfig = JSON.parse(fs.readFileSync(configPath, 'utf-8')) as TeamConfig;
          if (team.teammates.length >= teamConfig.maxTeammates) {
            throw new TeammateError(
              `Team ${teamName} has reached maximum teammates (${teamConfig.maxTeammates})`,
              TeammateErrorCode.PERMISSION_DENIED,
              teamName
            );
          }
        }
      }
    }

    const teammateId = generateId('teammate');

    const teammateInfo: TeammateInfo = {
      id: teammateId,
      name: config.name,
      role: config.role,
      status: 'active',
      spawnedAt: new Date(),
      messagesSent: 0,
      messagesReceived: 0,
      currentTask: config.prompt.slice(0, 100),
      delegatedPermissions: config.delegatedPermissions,
    };

    // Build AgentInput
    const agentInput = this.buildAgentInput({ ...config, teamName });

    // Add to team
    if (teamName) {
      let team = this.activeTeams.get(teamName);
      if (!team) {
        team = await this.loadTeam(teamName);
      }
      team.teammates.push(teammateInfo);

      // Create mailbox file
      const mailboxPath = this.getMailboxPath(teamName, teammateId);
      ensureDirectory(path.dirname(mailboxPath));
      if (!fs.existsSync(mailboxPath)) {
        fs.writeFileSync(mailboxPath, '[]', 'utf-8');
      }
    }

    this.emit('teammate:spawned', { teammate: teammateInfo, agentInput });

    return teammateInfo;
  }

  /**
   * Build AgentInput for Claude Code Task tool
   */
  buildAgentInput(config: TeammateSpawnConfig): AgentInput {
    return {
      description: `${config.role}: ${config.name}`,
      prompt: config.prompt,
      subagent_type: config.role,
      model: config.model,
      name: config.name,
      team_name: config.teamName ?? process.env.CLAUDE_CODE_TEAM_NAME,
      allowed_tools: config.allowedTools,
      mode: config.mode,
      run_in_background: config.runInBackground ?? true,
      max_turns: config.maxTurns,
    };
  }

  // ==========================================================================
  // Messaging
  // ==========================================================================

  /**
   * Send message to a specific teammate
   */
  async sendMessage(
    teamName: string,
    fromId: string,
    toId: string,
    message: { type: MessageType; payload: unknown; priority?: MailboxMessage['priority'] }
  ): Promise<MailboxMessage> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);

    const fullMessage: MailboxMessage = {
      id: generateId('msg'),
      from: fromId,
      to: toId,
      timestamp: new Date(),
      acknowledged: false,
      ...message,
    };

    // Write to recipient's mailbox
    await this.writeToMailbox(teamName, toId, fullMessage);

    team.messageCount++;

    // Update sender stats
    const sender = team.teammates.find(t => t.id === fromId);
    if (sender) sender.messagesSent++;

    this.emit('message:sent', { team: teamName, message: fullMessage });

    return fullMessage;
  }

  /**
   * Broadcast message to all teammates
   */
  async broadcast(
    teamName: string,
    fromId: string,
    message: { type: MessageType; payload: unknown; priority?: MailboxMessage['priority'] }
  ): Promise<MailboxMessage> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);

    const fullMessage: MailboxMessage = {
      id: generateId('broadcast'),
      from: fromId,
      to: 'broadcast',
      timestamp: new Date(),
      acknowledged: false,
      ...message,
    };

    // Write to all teammate mailboxes
    for (const teammate of team.teammates) {
      if (teammate.id !== fromId) {
        await this.writeToMailbox(teamName, teammate.id, fullMessage);
        teammate.messagesReceived++;
      }
    }

    team.messageCount += team.teammates.length - 1;

    this.emit('message:broadcast', { team: teamName, message: fullMessage });

    return fullMessage;
  }

  /**
   * Read messages from mailbox
   */
  async readMailbox(teamName: string, teammateId: string): Promise<MailboxMessage[]> {
    this.ensureAvailable();

    const mailboxPath = this.getMailboxPath(teamName, teammateId);

    try {
      if (!fs.existsSync(mailboxPath)) {
        return [];
      }

      const content = fs.readFileSync(mailboxPath, 'utf-8');
      const messages: MailboxMessage[] = JSON.parse(content);

      // Clear mailbox after reading
      fs.writeFileSync(mailboxPath, '[]', 'utf-8');

      // Parse dates
      return messages.map(m => ({
        ...m,
        timestamp: new Date(m.timestamp),
      }));
    } catch {
      return [];
    }
  }

  // ==========================================================================
  // Plan Approval System
  // ==========================================================================

  /**
   * Submit a plan for approval
   */
  async submitPlan(
    teamName: string,
    plan: Omit<TeamPlan, 'id' | 'approvals' | 'rejections' | 'status' | 'createdAt'>
  ): Promise<TeamPlan> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);

    const fullPlan: TeamPlan = {
      id: generateId('plan'),
      approvals: [],
      rejections: [],
      status: 'pending',
      createdAt: new Date(),
      ...plan,
    };

    team.activePlans.push(fullPlan);

    // Broadcast plan for approval
    await this.broadcast(teamName, plan.proposedBy, {
      type: 'plan',
      payload: fullPlan,
    });

    this.emit('plan:submitted', { team: teamName, plan: fullPlan });

    return fullPlan;
  }

  /**
   * Approve a plan
   */
  async approvePlan(teamName: string, planId: string, approverId: string): Promise<void> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);
    const plan = this.getPlanOrThrow(team, planId);

    if (plan.status !== 'pending') {
      throw new TeammateError(
        `Plan ${planId} is not pending (status: ${plan.status})`,
        TeammateErrorCode.PLAN_NOT_APPROVED,
        teamName
      );
    }

    if (!plan.approvals.includes(approverId)) {
      plan.approvals.push(approverId);
    }

    this.emit('plan:approval_added', { team: teamName, planId, approverId });

    // Check if we have enough approvals
    if (plan.approvals.length >= plan.requiredApprovals) {
      plan.status = 'approved';
      plan.approvedAt = new Date();
      this.emit('plan:approved', { team: teamName, plan });
    }
  }

  /**
   * Reject a plan
   */
  async rejectPlan(teamName: string, planId: string, rejecterId: string, reason?: string): Promise<void> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);
    const plan = this.getPlanOrThrow(team, planId);

    plan.rejections.push(rejecterId);
    plan.status = 'rejected';

    this.emit('plan:rejected', { team: teamName, plan, rejecterId, reason });
  }

  /**
   * Pause plan execution
   */
  async pausePlan(teamName: string, planId: string): Promise<void> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);
    const plan = this.getPlanOrThrow(team, planId);

    if (plan.status !== 'executing') {
      throw new TeammateError(
        `Plan ${planId} is not executing`,
        TeammateErrorCode.PLAN_NOT_APPROVED,
        teamName
      );
    }

    plan.status = 'paused';
    plan.pausedAt = plan.currentStep;

    this.emit('plan:paused', { team: teamName, planId, atStep: plan.currentStep ?? 0 });
  }

  /**
   * Resume plan execution
   */
  async resumePlan(teamName: string, planId: string, fromStep?: number): Promise<void> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);
    const plan = this.getPlanOrThrow(team, planId);

    if (plan.status !== 'paused') {
      throw new TeammateError(
        `Plan ${planId} is not paused`,
        TeammateErrorCode.PLAN_NOT_APPROVED,
        teamName
      );
    }

    plan.status = 'executing';
    plan.currentStep = fromStep ?? plan.pausedAt ?? 0;

    this.emit('plan:resumed', { team: teamName, planId, fromStep: plan.currentStep });
  }

  /**
   * Launch swarm to execute approved plan
   */
  async launchSwarm(teamName: string, planId: string, teammateCount?: number): Promise<ExitPlanModeInput> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);
    const plan = this.getPlanOrThrow(team, planId);

    if (plan.status !== 'approved') {
      throw new TeammateError(
        `Plan ${planId} is not approved`,
        TeammateErrorCode.PLAN_NOT_APPROVED,
        teamName
      );
    }

    const exitPlanInput: ExitPlanModeInput = {
      launchSwarm: true,
      teammateCount: teammateCount ?? plan.steps.length,
      allowedPrompts: plan.steps.map(step => ({
        tool: 'Bash' as const,
        prompt: step.action,
      })),
    };

    plan.status = 'executing';
    plan.startedAt = new Date();
    plan.currentStep = 0;

    this.emit('swarm:launched', {
      team: teamName,
      plan,
      exitPlanInput,
      teammateCount: exitPlanInput.teammateCount!,
    });

    return exitPlanInput;
  }

  // ==========================================================================
  // Delegation System (NEW)
  // ==========================================================================

  /**
   * Delegate authority to a teammate
   */
  async delegateToTeammate(
    teamName: string,
    fromId: string,
    toId: string,
    permissions: string[]
  ): Promise<DelegationRecord> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);

    // Check if source has these permissions or delegation rights
    const fromTeammate = team.teammates.find(t => t.id === fromId);
    if (!fromTeammate) {
      throw new TeammateError(
        `Teammate ${fromId} not found`,
        TeammateErrorCode.TEAMMATE_NOT_FOUND,
        teamName,
        fromId
      );
    }

    // Check delegation depth
    const existingDelegationChain = this.getDelegationChain(team, fromId);
    if (existingDelegationChain.length >= this.config.delegation.maxDepth) {
      throw new TeammateError(
        `Delegation depth exceeded (max: ${this.config.delegation.maxDepth})`,
        TeammateErrorCode.DELEGATION_DEPTH_EXCEEDED,
        teamName
      );
    }

    const delegation: DelegationRecord = {
      id: generateId('delegation'),
      fromId,
      toId,
      permissions,
      grantedAt: new Date(),
      expiresAt: this.config.delegation.autoExpireMs
        ? new Date(Date.now() + this.config.delegation.autoExpireMs)
        : undefined,
      depth: existingDelegationChain.length + 1,
      active: true,
    };

    team.delegations.push(delegation);

    // Update target teammate
    const toTeammate = team.teammates.find(t => t.id === toId);
    if (toTeammate) {
      toTeammate.delegatedFrom = fromId;
      toTeammate.delegatedPermissions = [
        ...(toTeammate.delegatedPermissions ?? []),
        ...permissions,
      ];
    }

    // Notify via message
    await this.sendMessage(teamName, fromId, toId, {
      type: 'delegation',
      payload: { action: 'granted', permissions },
    });

    this.emit('delegate:granted', { team: teamName, from: fromId, to: toId, permissions });

    return delegation;
  }

  /**
   * Revoke delegation from a teammate
   */
  async revokeDelegation(teamName: string, fromId: string, toId: string): Promise<void> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);

    const delegationIndex = team.delegations.findIndex(
      d => d.fromId === fromId && d.toId === toId && d.active
    );

    if (delegationIndex === -1) {
      throw new TeammateError(
        `No active delegation from ${fromId} to ${toId}`,
        TeammateErrorCode.DELEGATION_DENIED,
        teamName
      );
    }

    team.delegations[delegationIndex].active = false;

    // Update target teammate
    const toTeammate = team.teammates.find(t => t.id === toId);
    if (toTeammate) {
      const delegation = team.delegations[delegationIndex];
      toTeammate.delegatedPermissions = (toTeammate.delegatedPermissions ?? [])
        .filter(p => !delegation.permissions.includes(p));

      if (toTeammate.delegatedPermissions.length === 0) {
        toTeammate.delegatedFrom = undefined;
      }
    }

    // Notify via message
    await this.sendMessage(teamName, fromId, toId, {
      type: 'delegation',
      payload: { action: 'revoked' },
    });

    this.emit('delegate:revoked', { team: teamName, from: fromId, to: toId });
  }

  // ==========================================================================
  // Team Context (NEW)
  // ==========================================================================

  /**
   * Update team context
   */
  async updateTeamContext(
    teamName: string,
    updates: Partial<TeamContext>
  ): Promise<TeamContext> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);

    const updatedKeys: string[] = [];

    if (updates.sharedVariables) {
      team.context.sharedVariables = {
        ...team.context.sharedVariables,
        ...updates.sharedVariables,
      };
      updatedKeys.push(...Object.keys(updates.sharedVariables));
    }

    if (updates.inheritedPermissions) {
      team.context.inheritedPermissions = [
        ...new Set([...team.context.inheritedPermissions, ...updates.inheritedPermissions]),
      ];
      updatedKeys.push('inheritedPermissions');
    }

    if (updates.workingDirectory) {
      team.context.workingDirectory = updates.workingDirectory;
      updatedKeys.push('workingDirectory');
    }

    if (updates.gitBranch !== undefined) {
      team.context.gitBranch = updates.gitBranch;
      updatedKeys.push('gitBranch');
    }

    if (updates.environmentVariables) {
      team.context.environmentVariables = {
        ...team.context.environmentVariables,
        ...updates.environmentVariables,
      };
      updatedKeys.push(...Object.keys(updates.environmentVariables));
    }

    // Broadcast context update
    await this.broadcast(teamName, 'system', {
      type: 'context_update',
      payload: { updates, keys: updatedKeys },
    });

    this.emit('context:updated', { team: teamName, keys: updatedKeys });

    return team.context;
  }

  /**
   * Get team context
   */
  getTeamContext(teamName: string): TeamContext {
    const team = this.getTeamOrThrow(teamName);
    return { ...team.context };
  }

  // ==========================================================================
  // Permission Updates (NEW)
  // ==========================================================================

  /**
   * Update teammate permissions
   */
  async updateTeammatePermissions(
    teamName: string,
    teammateId: string,
    changes: { add?: string[]; remove?: string[] }
  ): Promise<string[]> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);
    const teammate = team.teammates.find(t => t.id === teammateId);

    if (!teammate) {
      throw new TeammateError(
        `Teammate ${teammateId} not found`,
        TeammateErrorCode.TEAMMATE_NOT_FOUND,
        teamName,
        teammateId
      );
    }

    const currentPermissions = teammate.delegatedPermissions ?? [];
    let newPermissions = [...currentPermissions];

    const added: string[] = [];
    const removed: string[] = [];

    if (changes.add) {
      for (const perm of changes.add) {
        if (!newPermissions.includes(perm)) {
          newPermissions.push(perm);
          added.push(perm);
        }
      }
    }

    if (changes.remove) {
      newPermissions = newPermissions.filter(p => {
        if (changes.remove!.includes(p)) {
          removed.push(p);
          return false;
        }
        return true;
      });
    }

    teammate.delegatedPermissions = newPermissions;

    this.emit('permissions:updated', { team: teamName, teammateId, added, removed });

    return newPermissions;
  }

  // ==========================================================================
  // Remote Sync (NEW)
  // ==========================================================================

  /**
   * Push team to Claude.ai remote
   */
  async pushTeamToRemote(teamName: string): Promise<RemoteSession> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);

    // This would integrate with Claude Code's pushToRemote functionality
    // For now, we simulate the remote session creation
    const remoteSession: RemoteSession = {
      remoteSessionId: generateId('remote'),
      remoteSessionUrl: `https://claude.ai/project/${generateId('proj')}`,
      syncedAt: new Date(),
      status: 'connected',
    };

    team.remoteSessionId = remoteSession.remoteSessionId;
    team.remoteSessionUrl = remoteSession.remoteSessionUrl;

    // Save remote session info
    const teamDir = path.join(this.teamsDir, teamName);
    fs.writeFileSync(
      path.join(teamDir, 'remote.json'),
      JSON.stringify(remoteSession, null, 2),
      'utf-8'
    );

    this.emit('remote:pushed', { team: teamName, remoteUrl: remoteSession.remoteSessionUrl });

    return remoteSession;
  }

  /**
   * Sync with remote
   */
  async syncWithRemote(teamName: string): Promise<SyncResult> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);

    if (!team.remoteSessionId) {
      throw new TeammateError(
        `Team ${teamName} is not connected to remote`,
        TeammateErrorCode.REMOTE_SYNC_FAILED,
        teamName
      );
    }

    // Simulate sync result
    const result: SyncResult = {
      success: true,
      changesPushed: 0,
      changesPulled: 0,
      conflicts: 0,
      remoteUrl: team.remoteSessionUrl,
    };

    this.emit('remote:synced', { team: teamName, result });

    return result;
  }

  // ==========================================================================
  // Session Memory (NEW)
  // ==========================================================================

  /**
   * Save teammate memory
   */
  async saveTeammateMemory(teamName: string, teammateId: string): Promise<void> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);
    const teammate = team.teammates.find(t => t.id === teammateId);

    if (!teammate) {
      throw new TeammateError(
        `Teammate ${teammateId} not found`,
        TeammateErrorCode.TEAMMATE_NOT_FOUND,
        teamName,
        teammateId
      );
    }

    const memoryKey = `${teamName}:${teammateId}`;
    let memory = this.teammateMemories.get(memoryKey);

    if (!memory) {
      memory = {
        sessionId: generateId('session'),
        teammateId,
        teamName,
        transcript: [],
        context: {},
        nestedMemories: [],
        createdAt: new Date(),
        updatedAt: new Date(),
        size: 0,
      };
    }

    // Read mailbox messages as transcript
    const mailboxPath = this.getMailboxPath(teamName, teammateId);
    if (fs.existsSync(mailboxPath)) {
      const messages = JSON.parse(fs.readFileSync(mailboxPath, 'utf-8')) as MailboxMessage[];
      memory.transcript.push(...messages);
    }

    memory.updatedAt = new Date();
    memory.size = JSON.stringify(memory).length;

    this.teammateMemories.set(memoryKey, memory);

    // Persist to disk
    const memoryDir = path.join(this.teamsDir, teamName, 'memory');
    ensureDirectory(memoryDir);
    fs.writeFileSync(
      path.join(memoryDir, `${teammateId}.json`),
      JSON.stringify(memory, null, 2),
      'utf-8'
    );

    this.emit('memory:saved', { team: teamName, teammateId, size: memory.size });
  }

  /**
   * Load teammate memory
   */
  async loadTeammateMemory(teamName: string, teammateId: string): Promise<TeammateMemory | null> {
    this.ensureAvailable();

    const memoryPath = path.join(this.teamsDir, teamName, 'memory', `${teammateId}.json`);

    if (!fs.existsSync(memoryPath)) {
      return null;
    }

    try {
      const memory = JSON.parse(fs.readFileSync(memoryPath, 'utf-8')) as TeammateMemory;

      // Parse dates
      memory.createdAt = new Date(memory.createdAt);
      memory.updatedAt = new Date(memory.updatedAt);
      memory.transcript = memory.transcript.map(m => ({
        ...m,
        timestamp: new Date(m.timestamp),
      }));

      const memoryKey = `${teamName}:${teammateId}`;
      this.teammateMemories.set(memoryKey, memory);

      this.emit('memory:loaded', { team: teamName, teammateId });

      return memory;
    } catch {
      throw new TeammateError(
        `Failed to load memory for ${teammateId}`,
        TeammateErrorCode.MEMORY_LOAD_FAILED,
        teamName,
        teammateId
      );
    }
  }

  /**
   * Share transcript between teammates
   */
  async shareTranscript(
    teamName: string,
    fromId: string,
    toId: string,
    options?: { start?: number; end?: number }
  ): Promise<void> {
    this.ensureAvailable();

    const memory = await this.loadTeammateMemory(teamName, fromId);

    if (!memory) {
      throw new TeammateError(
        `No memory found for ${fromId}`,
        TeammateErrorCode.MEMORY_LOAD_FAILED,
        teamName,
        fromId
      );
    }

    let transcript = memory.transcript;

    if (options?.start !== undefined || options?.end !== undefined) {
      transcript = transcript.slice(options.start, options.end);
    }

    await this.sendMessage(teamName, fromId, toId, {
      type: 'result',
      payload: {
        transcriptShare: true,
        messages: transcript,
        fromTeammate: fromId,
      },
    });

    this.emit('transcript:shared', {
      team: teamName,
      from: fromId,
      to: toId,
      messageCount: transcript.length,
    });
  }

  // ==========================================================================
  // Teleport (NEW)
  // ==========================================================================

  /**
   * Check if team can teleport
   */
  async canTeleport(teamName: string, target: TeleportTarget): Promise<{ canTeleport: boolean; blockers: string[] }> {
    this.ensureAvailable();

    const blockers: string[] = [];

    // Check team exists
    if (!this.activeTeams.has(teamName)) {
      const teams = await this.discoverTeams();
      if (!teams.includes(teamName)) {
        blockers.push(`Team ${teamName} not found`);
      }
    }

    // Check git compatibility if gitAware
    if (this.config.teleport.gitAware && target.gitRepo) {
      const currentRepo = this.getCurrentGitRepo();
      if (currentRepo && currentRepo !== target.gitRepo) {
        blockers.push(`Git repository mismatch: current=${currentRepo}, target=${target.gitRepo}`);
      }
    }

    // Check working directory exists
    if (target.workingDirectory && !fs.existsSync(target.workingDirectory)) {
      blockers.push(`Working directory not found: ${target.workingDirectory}`);
    }

    return {
      canTeleport: blockers.length === 0,
      blockers,
    };
  }

  /**
   * Teleport team to new context
   */
  async teleportTeam(teamName: string, target: TeleportTarget): Promise<TeleportResult> {
    this.ensureAvailable();

    this.emit('teleport:started', { team: teamName, target });

    const { canTeleport, blockers } = await this.canTeleport(teamName, target);

    if (!canTeleport) {
      const error = `Cannot teleport: ${blockers.join(', ')}`;
      this.emit('teleport:failed', { team: teamName, error });
      return { success: false, blockers };
    }

    try {
      // Save current state
      await this.saveTeamState(teamName);

      // Update context
      const team = await this.loadTeam(teamName);

      if (target.workingDirectory) {
        team.context.workingDirectory = target.workingDirectory;
      }

      if (target.gitBranch) {
        team.context.gitBranch = target.gitBranch;
      }

      if (target.gitRepo) {
        team.context.gitRepo = target.gitRepo;
      }

      // Save updated state
      await this.saveTeamState(teamName);

      const result: TeleportResult = {
        success: true,
        teamState: team,
      };

      this.emit('teleport:completed', { team: teamName, result });

      return result;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      this.emit('teleport:failed', { team: teamName, error: errorMsg });
      return { success: false, blockers: [errorMsg] };
    }
  }

  // ==========================================================================
  // Shutdown
  // ==========================================================================

  /**
   * Request teammate shutdown
   */
  async requestShutdown(teamName: string, teammateId: string, reason?: string): Promise<void> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);
    const teammate = team.teammates.find(t => t.id === teammateId);

    if (teammate) {
      teammate.status = 'shutdown_pending';
    }

    this.emit('teammate:shutdown_requested', { team: teamName, teammateId, reason });
  }

  /**
   * Approve teammate shutdown
   */
  async approveShutdown(teamName: string, teammateId: string): Promise<void> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);

    // Save memory before shutdown
    if (this.config.memory.autoPersist) {
      try {
        await this.saveTeammateMemory(teamName, teammateId);
      } catch {
        // Ignore memory save errors during shutdown
      }
    }

    team.teammates = team.teammates.filter(t => t.id !== teammateId);

    this.emit('teammate:shutdown_approved', { team: teamName, teammateId });
  }

  /**
   * Reject teammate shutdown
   */
  async rejectShutdown(teamName: string, teammateId: string): Promise<void> {
    this.ensureAvailable();

    const team = this.getTeamOrThrow(teamName);
    const teammate = team.teammates.find(t => t.id === teammateId);

    if (teammate) {
      teammate.status = 'active';
    }

    this.emit('teammate:shutdown_rejected', { team: teamName, teammateId });
  }

  /**
   * Cleanup team resources
   */
  async cleanup(teamName: string): Promise<void> {
    this.ensureAvailable();

    // Stop mailbox poller
    const poller = this.mailboxPollers.get(teamName);
    if (poller) {
      clearInterval(poller);
      this.mailboxPollers.delete(teamName);
    }

    // Stop memory persistence
    const memoryTimer = this.memoryPersistTimers.get(teamName);
    if (memoryTimer) {
      clearInterval(memoryTimer);
      this.memoryPersistTimers.delete(teamName);
    }

    // Save final state
    try {
      await this.saveTeamState(teamName);
    } catch {
      // Ignore save errors during cleanup
    }

    // Remove from active teams
    this.activeTeams.delete(teamName);

    // Clear environment
    if (process.env.CLAUDE_CODE_TEAM_NAME === teamName) {
      delete process.env.CLAUDE_CODE_TEAM_NAME;
    }

    this.emit('team:cleanup', { team: teamName });
  }

  // ==========================================================================
  // Utility Methods
  // ==========================================================================

  /**
   * Get team state
   */
  getTeamState(teamName: string): TeamState | undefined {
    return this.activeTeams.get(teamName);
  }

  /**
   * Get all active teams
   */
  getAllTeams(): Map<string, TeamState> {
    return new Map(this.activeTeams);
  }

  /**
   * Get backend status
   */
  async getBackendStatus(): Promise<BackendStatus[]> {
    const statuses: BackendStatus[] = [];

    // tmux backend
    try {
      execSync('which tmux', { encoding: 'utf-8' });
      statuses.push({
        backend: 'tmux',
        available: true,
        activeTeammates: 0,
        capacity: 100,
      });
    } catch {
      statuses.push({
        backend: 'tmux',
        available: false,
        activeTeammates: 0,
        capacity: 0,
      });
    }

    // in_process backend (always available)
    let inProcessCount = 0;
    for (const team of this.activeTeams.values()) {
      inProcessCount += team.teammates.length;
    }

    statuses.push({
      backend: 'in_process',
      available: true,
      activeTeammates: inProcessCount,
      capacity: 50,
    });

    return statuses;
  }

  // ==========================================================================
  // Private Methods
  // ==========================================================================

  private ensureAvailable(): void {
    if (!this.initialized) {
      throw new TeammateError(
        'TeammateBridge not initialized. Call initialize() first.',
        TeammateErrorCode.VERSION_INCOMPATIBLE
      );
    }

    if (!this.teammateToolAvailable && !this.config.fallbackToMCP) {
      throw new TeammateError(
        `TeammateTool not available. Requires Claude Code >= ${MINIMUM_CLAUDE_CODE_VERSION}, ` +
        `found: ${this.claudeCodeVersion ?? 'not installed'}`,
        TeammateErrorCode.VERSION_INCOMPATIBLE
      );
    }
  }

  private getTeamOrThrow(teamName: string): TeamState {
    const team = this.activeTeams.get(teamName);
    if (!team) {
      throw new TeammateError(
        `Team not found: ${teamName}`,
        TeammateErrorCode.TEAM_NOT_FOUND,
        teamName
      );
    }
    return team;
  }

  private getPlanOrThrow(team: TeamState, planId: string): TeamPlan {
    const plan = team.activePlans.find(p => p.id === planId);
    if (!plan) {
      throw new TeammateError(
        `Plan not found: ${planId}`,
        TeammateErrorCode.PLAN_NOT_FOUND,
        team.name
      );
    }
    return plan;
  }

  private getMailboxPath(teamName: string, teammateId: string): string {
    return path.join(this.teamsDir, teamName, 'mailbox', `${teammateId}.json`);
  }

  private async writeToMailbox(
    teamName: string,
    teammateId: string,
    message: MailboxMessage
  ): Promise<void> {
    const mailboxPath = this.getMailboxPath(teamName, teammateId);
    ensureDirectory(path.dirname(mailboxPath));

    let messages: MailboxMessage[] = [];

    if (fs.existsSync(mailboxPath)) {
      try {
        messages = JSON.parse(fs.readFileSync(mailboxPath, 'utf-8'));
      } catch {
        messages = [];
      }
    }

    // Check mailbox size limit
    if (messages.length >= this.config.mailbox.maxMessages) {
      // Remove oldest messages
      messages = messages.slice(-Math.floor(this.config.mailbox.maxMessages * 0.9));
    }

    messages.push(message);

    fs.writeFileSync(mailboxPath, JSON.stringify(messages, null, 2), 'utf-8');
  }

  private startMailboxPoller(teamName: string): void {
    if (this.mailboxPollers.has(teamName)) {
      return;
    }

    const pollInterval = this.config.mailbox.pollingIntervalMs;

    const poller = setInterval(async () => {
      const team = this.activeTeams.get(teamName);
      if (!team) {
        clearInterval(poller);
        this.mailboxPollers.delete(teamName);
        return;
      }

      for (const teammate of team.teammates) {
        try {
          const mailboxPath = this.getMailboxPath(teamName, teammate.id);
          if (fs.existsSync(mailboxPath)) {
            const content = fs.readFileSync(mailboxPath, 'utf-8');
            const messages: MailboxMessage[] = JSON.parse(content);

            if (messages.length > 0) {
              this.emit('mailbox:messages', {
                team: teamName,
                teammateId: teammate.id,
                messages: messages.map(m => ({
                  ...m,
                  timestamp: new Date(m.timestamp),
                })),
              });
            }
          }
        } catch {
          // Ignore individual mailbox read errors
        }
      }
    }, pollInterval);

    this.mailboxPollers.set(teamName, poller);
  }

  private startMemoryPersistence(teamName: string): void {
    if (this.memoryPersistTimers.has(teamName)) {
      return;
    }

    const persistInterval = this.config.memory.persistIntervalMs;

    const timer = setInterval(async () => {
      const team = this.activeTeams.get(teamName);
      if (!team) {
        clearInterval(timer);
        this.memoryPersistTimers.delete(teamName);
        return;
      }

      for (const teammate of team.teammates) {
        try {
          await this.saveTeammateMemory(teamName, teammate.id);
        } catch {
          // Ignore individual memory save errors
        }
      }
    }, persistInterval);

    this.memoryPersistTimers.set(teamName, timer);
  }

  private async saveTeamState(teamName: string): Promise<void> {
    const team = this.activeTeams.get(teamName);
    if (!team) return;

    const teamDir = path.join(this.teamsDir, teamName);
    ensureDirectory(teamDir);

    fs.writeFileSync(
      path.join(teamDir, 'state.json'),
      JSON.stringify(team, null, 2),
      'utf-8'
    );
  }

  private getDelegationChain(team: TeamState, teammateId: string): DelegationRecord[] {
    const chain: DelegationRecord[] = [];
    let currentId = teammateId;

    while (true) {
      const delegation = team.delegations.find(d => d.toId === currentId && d.active);
      if (!delegation) break;

      chain.push(delegation);
      currentId = delegation.fromId;

      // Prevent infinite loops
      if (chain.length > 10) break;
    }

    return chain;
  }

  private getCurrentGitBranch(): string | undefined {
    try {
      return execSync('git rev-parse --abbrev-ref HEAD 2>/dev/null', {
        encoding: 'utf-8',
      }).trim() || undefined;
    } catch {
      return undefined;
    }
  }

  private getCurrentGitRepo(): string | undefined {
    try {
      return execSync('git config --get remote.origin.url 2>/dev/null', {
        encoding: 'utf-8',
      }).trim() || undefined;
    } catch {
      return undefined;
    }
  }
}

// ============================================================================
// Factory Function
// ============================================================================

/**
 * Create and initialize a TeammateBridge instance
 */
export async function createTeammateBridge(
  config?: Partial<PluginConfig>
): Promise<TeammateBridge> {
  const bridge = new TeammateBridge(config);
  await bridge.initialize();
  return bridge;
}

export default TeammateBridge;
